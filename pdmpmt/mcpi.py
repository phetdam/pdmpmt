"""Monte Carlo estimation of pi.

Uses the standard "circle-filling" technique to estimate pi / 4.

.. codeauthor:: Derek Huang <djh458@stern.nyu.edu>
"""

from typing import Iterable, Optional

import numpy as np

# maximum value fo the random seed integers generated by generate_seeds
MAX_SEED_DEFAULT = 89000
# default number of samples to use
N_SAMPLES_DEFAULT = 100000000


def generate_seeds(
    n_seeds: int,
    initial_seed: Optional[int] = None,
    max_seed: int = MAX_SEED_DEFAULT
) -> np.ndarray:
    """Generate an array shape (n_seeds,) of seeds for the NumPy PRNG.

    Seed values are selected with replacement from [0, max_seed).

    n_seeds : int
        Number of seed values to generate
    initial_seed : int, default=None
        Seed for NumPy PRNG for reproducibility
    max_seed : int, default=MAX_SEED_DEFAULT
        Upper bound for the generated seed values
    """
    rng = np.random.default_rng(initial_seed)
    return rng.integers(max_seed, high=None, size=n_seeds)


def unit_circle_samples(n_samples: int, seed: Optional[int] = None) -> int:
    """Return number of samples that fall inside the unit circle.

    This function performs the majority of the work needed to estimate pi.

    Parameters
    ----------
    n_samples : int
        Number of samples to draw from [-1, 1] X [-1, 1]
    seed : int, default=None
        Seed for NumPy PRNG for reproducibility
    """
    rng = np.random.default_rng(seed)
    points = rng.uniform(low=-1., high=1., size=(n_samples, 2))
    norms = np.linalg.norm(points, axis=1)
    return norms[norms <= 1.].size


def mcpi_gather(
    circle_counts: Iterable[int], sample_counts: Iterable[int]
) -> float:
    """Estimate pi from computed circle and sample counts.

    Parameters
    ----------
    circle_counts : Iterable[int]
        Iterable of counts of samples per batch falling in the unit circle
    sample_counts : Iterable[int]
        Iterable of the total samples per batch
    """
    # use int64 and divide the two counts first to reduce chance of overflow
    return 4 * (
        np.sum(circle_counts, dtype=np.int64) /
        np.sum(sample_counts, dtype=np.int64)
    )


def mcpi_serial(
    n_samples: int = N_SAMPLES_DEFAULT, seed: Optional[int] = None
) -> float:
    """Serial estimation of pi using Monte Carlo.

    This can be considered the "optimal" single-process Python implementation.

    Parameters
    ----------
    n_samples : int, default=N_SAMPLES_DEFAULT
        Number of samples to draw
    seed : int, default=None
        Seed for NumPy PRNG seed for reproducibility
    """
    # again divide the two integers before multiplying by 4 to avoid overflow
    return 4 * (unit_circle_samples(n_samples, seed=seed) / n_samples)
